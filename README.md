# Matrices for AllScale #

Provides the "Matrix" data type for the allscale_api. It consists of:


## The Matrix Type ##

### api/include/data/matrix.h ###
This is the main implementation file, it provides the Matrix class,
which is built on top of the Grid container. Operations supported
are:
- Matrix/Matrix Addition
- Matrix/Matrix Subtraction
- Matrix Negation
- Matrix Multiplication
- Matrix initialisation from random
- Matrix initialisation from zero
- Matrix initialisation from a Eigen::Matrix
- Conversion of our Matrix type to Eigen::Matrix

Note that operations like Addition, Subtraction and Negation are
implemented using template expressions, meaning the evaluation is only done
lazily, usually when assigning the final result, or explicitly by using the
eval() function. This approach can greatly improve the performance in complex
matrix operation expressions.

## Test for the Matrix Type ##
### src/test/user/data/matrix.cc ###
Test for the Matrix data type.

## Benchmarking ##
### src/benchmark/mm_eigen.cc ###
Creates an executable that runs timed matrix multiplications and
prints out the measured times. Useful for comparing the eigen
matrix multiplication implementation with our (Eigen based)
implementation.

Note eigen supports openmp for parallel matrix multiplication, use
OMP_NUM_THREADS=N ./mm_eigen_benchmark - parallel execution is
enabled by default.

### src/benchmark/mm_allscale.cc ###
Similar to the above, but for our own matrix multiplication, the
parallel part is now handled by allscale, to specify the number
of threads use: NUM_WORKERS=N ./mm_allscale_benchmark

Again parallel execution is enabled by default.

### src/benchmark/build.sh ###
Bash shell script which builds the matrix multiplication benchmarks. The
generated executables are mm_eigen and mm_allscale. If they are passed
no parameters, they will provide a pretty (human-readable) summary of the
results of multiplying two square 650x650 matrices.
You can pass the size N of the NxN matrices to be multiplied as first parameter
to the executables. If you include a second parameter the output will switch to
a flat list of each of the benchmarking results, useful when evaluating the
benchmarks in a automated way.

### src/benchmark/run_benchmark_suite.sh ###
Bash shell script, this will build the benchmarks and run them multiple times
in various configurations, that can be configured at the beginning of the shell
script.
The output on standard-out is designed to be well parsable by R for
visualisation. Usually you will want to run it like this:
./run_benchmark_suite.sh > my_benchmark_results.dat

### src/benchmark/boxplot_graph.R ###
This is a R script which uses the dat files generated by run_benchmark_suite.sh
to create nice boxplot visualisations, showing the results of the benchmarks
run.
The usual way to run it is via: Rscript boxplot_graph.R my_benchmark_results.dat
That command will generate my_benchmark_results.pdf which contains the graphics.
